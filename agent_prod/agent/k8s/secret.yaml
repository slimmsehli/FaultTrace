# ══════════════════════════════════════════════════════════════════════════════
# k8s/secret.yaml — FaultTrace API Key Secrets
# ══════════════════════════════════════════════════════════════════════════════
#
# NEVER commit real keys here. Use one of these approaches:
#
# Option A — kubectl with real values (recommended for CI):
#   kubectl create secret generic faulttrace-secrets \
#     --from-literal=openai-api-key="sk-..." \
#     --from-literal=anthropic-api-key="sk-ant-..." \
#     --from-literal=google-api-key="AIza..." \
#     --namespace=faulttrace
#
# Option B — Sealed Secrets (recommended for GitOps):
#   kubeseal --format=yaml < secret.yaml > sealed-secret.yaml
#
# Option C — External Secrets Operator (AWS/GCP/Vault):
#   Use ExternalSecret CR pointing at your secret store.
#
# Option D — Apply this file with placeholder values and patch in CI:
#   kubectl patch secret faulttrace-secrets -p '{"data":{"openai-api-key":"<base64>"}}'
# ══════════════════════════════════════════════════════════════════════════════

apiVersion: v1
kind: Secret
metadata:
  name: faulttrace-secrets
  namespace: faulttrace
  labels:
    app: faulttrace
type: Opaque
stringData:
  # Fill in the key(s) for your chosen provider.
  # Unused keys can be left as empty strings.
  openai-api-key:    ""   # sk-...
  anthropic-api-key: ""   # sk-ant-...
  google-api-key:    ""   # AIza...
  vllm-api-key:      "token-abc123"
