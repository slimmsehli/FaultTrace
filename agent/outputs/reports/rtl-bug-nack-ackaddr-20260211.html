<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Rtl Bug Nack Ackaddr 20260211</title>
  <style>
body{font-family:system-ui,Arial,Helvetica;margin:24px;line-height:1.5} h1{font-size:20px;margin-bottom:8px} pre{background:#f6f8fa;padding:12px;border-radius:6px;overflow:auto} ul{margin-top:8px}
</style>
</head>
<body>
<h1>RTL Bug Report - rtl-bug-nack-ackaddr-20260211</h1>
<h2>1) Summary</h2>
<ul>
<li>Analysis ID: rtl-bug-nack-ackaddr-20260211</li>
<li>Module: i2c_slave_dut (design.sv)</li>
<li>Test: i2c_test (testbench.sv)</li>
<li>Repro command / log: /home/slim/FaultTrace/simulation/sim.log (sim invoked via simv, see top of log)</li>
<li>Environment: Simulation VCD at /home/slim/FaultTrace/simulation/sim.vcd (timescale 1ns).</li>
</ul>

<h2>2) Symptoms & Evidence</h2>
<p>Simulation reported a UVM_ERROR from the driver when waiting for ACK during the Address phase:</p>
<pre>UVM_ERROR testbench.sv(146) @ 1795: uvm_test_top.env.agent.driver [DRV] NACK (No ACK) received during Address phase</pre>

<p>Relevant log excerpt:</p>
<pre>UVM_INFO testbench.sv(84) @ 0: uvm_test_top.env.agent.driver [DRV] Starting Write: Addr=50 Data=95
UVM_ERROR testbench.sv(146) @ 1795: uvm_test_top.env.agent.driver [DRV] NACK (No ACK) received during Address phase
</pre>

<p>At the time of the error (timestamp ~1795), VCD sampling shows the master released SDA (expecting ACK from slave) but the DUT is not driving ACK low:</p>
<pre>
Timestamp 1795 values (selected signals):
- top.intf.sda                = 1
- top.intf.sda_drive_out      = 1   (master released SDA)
- top.dut.sda_out_en         = 0   (dut not driving ACK)
- top.dut.sda                = 1
- top.intf.scl               = 1
- top.intf.scl_drive_out     = 1
- top.dut.scl_d              = 1
- top.dut.sda_d              = 1
</pre>

<p>Aligned transitions in window [1700..1900] (VCD): times at which signals changed: [1700,1705,1745,1755,1845,1855,1895]. At the expected ACK window the DUT's sda_out_en remains 0 (not asserting ACK).</p>

<h2>3) Root Cause</h2>
<p>Bug in DUT address matching logic (off-by-one bit selection). In /home/slim/FaultTrace/simulation/design.sv the code compares the wrong bits of the shift register to the slave address:</p>
<pre>if (shift_reg[6:0] == SLAVE_ADDR) begin</pre>

<p>Because shift_reg is assembled with shift_reg <= {shift_reg[6:0], sda}; and the master transmits MSB first, after receiving the full byte the 7-bit address resides in shift_reg[7:1] while bit 0 contains R/W. Comparing shift_reg[6:0] therefore compares the wrong set of bits (it omits the MSB of the address and includes the R/W bit), so the address never matches and the DUT never transitions to ACK_ADDR; hence sda_out_en stays 0 and the master sees NACK.</p>

<h2>4) Fix (precise change)</h2>
<p>Edit file: /home/slim/FaultTrace/simulation/design.sv</p>
<p>Location: around line 81 (in the MATCH_ADDR case). Replace:</p>
<pre>                                if (shift_reg[6:0] == SLAVE_ADDR) begin</pre>

<p>With:</p>
<pre>                                if (shift_reg[7:1] == SLAVE_ADDR) begin</pre>

<p>Rationale: shift_reg[7:1] contains the 7 received address bits (MSB-first) after 8 shifts (bits 7..1 = addr[6..0]).</p>

<p>Suggested minimal diff (for convenience):</p>
<pre>--- a/simulation/design.sv
+++ b/simulation/design.sv
@@ -79,7 +79,7 @@
-                                // We check top 7 bits against SLAVE_ADDR
-                                if (shift_reg[6:0] == SLAVE_ADDR) begin
+                                // We check received 7-bit address (bits 7:1) against SLAVE_ADDR
+                                if (shift_reg[7:1] == SLAVE_ADDR) begin
                                     state <= ACK_ADDR;
                                 end else begin
                                     state <= IDLE; // Not our address
</pre>

<h2>5) Verification / Evidence for fix</h2>
<p>After this fix, when the master sends the address byte, the DUT will match shift_reg[7:1] to SLAVE_ADDR and enter ACK_ADDR; sda_out_en will be asserted during the ACK window and the master will observe SDA=0 (ACK). The VCD evidence previously showed sda_out_en==0 during the ACK window; correcting the bit select addresses the root cause.</p>

<h2>6) Next Steps / Action Items</h2>
<ul>
<li>Apply the one-line change at /home/slim/FaultTrace/simulation/design.sv (around line 81) and re-run the simulation.</li>
<li>Re-check the VCD around the ACK window: top.dut.sda_out_en should become 1 (drive 0) while master has released SDA; driver should log ACK received and no UVM_ERROR should occur.</li>
<li>Add a unit test in the DUT testbench to assert correct address matching (optional): check that on matching address sda_out_en is asserted).</li>
</ul>

<h2>7) Appendix - Files inspected</h2>
<ul>
<li>/home/slim/FaultTrace/simulation/sim.log (UVM error at testbench.sv(146))</li>
<li>/home/slim/FaultTrace/simulation/testbench.sv (driver code, check_ack task at lines ~128-146)</li>
<li>/home/slim/FaultTrace/simulation/design.sv (dut, MATCH_ADDR handling lines ~72-82)</li>
<li>/home/slim/FaultTrace/simulation/sim.vcd (signals sampled to confirm sda_out_en==0 at ACK time)</li>
</ul>


</body>
</html>