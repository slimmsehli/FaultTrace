<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Rtl Bug Analysis 0001 I2C Slave 20260211</title>
  <style>
body { font-family: system-ui, sans-serif; line-height: 1.5; margin: 2rem; color: #333; } pre { background: #f4f4f4; padding: 1rem; border-radius: 4px; border: 1px solid #ddd; } .timing-diagram { font-family: "Courier New", Courier, monospace; line-height: 1.2; background: #1e1e1e; color: #dcdcdc; padding: 1rem; } .confidence-high { color: #28a745; font-weight: bold; }
</style>
</head>
<body>
<h1>RTL Bug Report – ANALYSIS-0001 (i2c_slave)</h1>
<p class="confidence-high">Confidence: 95% - Root cause verified via VCD checks showing DUT never drives ACK and RTL logic inspection showing an off-by-one index in the address-compare.</p>

<h2>Summary</h2>
<ul>
<li>Module: i2c_slave_dut (design.sv)</li>
<li>Test: i2c_test (uvm) — run command recorded in sim.log</li>
<li>Simulation log: /home/runner/work/FaultTrace/FaultTrace/simulation/sim.log</li>
<li>VCD: /home/runner/work/FaultTrace/FaultTrace/simulation/sim.vcd</li>
<li>Environment: VCS X-2025.06-SP2_Full64; UVM 1.2</li>
</ul>

<h2>Symptoms & Evidence</h2>
<p>UVM errors in sim.log show repeated NACKs reported by the driver during both Address and Data phases:</p>
<pre>
UVM_ERROR testbench.sv(146) @ 1795: uvm_test_top.env.agent.driver [DRV] NACK (No ACK) received during Address phase
UVM_ERROR testbench.sv(146) @ 3545: uvm_test_top.env.agent.driver [DRV] NACK (No ACK) received during Data phase
... (repeated for 3 transactions)
</pre>

<p>Key VCD samples at error timestamps (values at or before timestamp):</p>
<pre>
Timestamp: 1795 ns
 top.intf.scl           = 1
 top.intf.sda           = 1   (pulled high by pullup)
 top.intf.sda_drive_out = 1   (master released SDA to float)
 top.intf.scl_drive_out = 1
 top.dut.sda_out_en     = 0   (DUT not driving ACK)
</pre>

<p>Same pattern occurs at the other error times (3545 ns, 5745 ns, ...): master releases SDA expecting ACK, but dut.sda_out_en remains 0 and SDA stays high -> master records NACK.</p>

<h2>Visual Timing Diagram (around 1795 ns)</h2>
<pre class="timing-diagram">
Time    : 1780ns   1795ns   1810ns
SCL     : _______\__________________ (SCL = 1 at sample)
SDA_m   : ________\_________________ (Master released SDA -> floats high)
SDA_net : ________\_________________ (Pulled High by pullup)
sda_out_en (dut): ______0__________   (stays 0, no ACK driven)
State   :  ... START | ADDR_BITS | ACK?   
</pre>

<h2>Root Cause</h2>
<p>Bug in DUT RTL (design.sv): the 7-bit address extracted from the received serial data is compared incorrectly with the hardcoded SLAVE_ADDR. The code compares shift_reg[6:0] against SLAVE_ADDR; however, after 8 serial shifts (7 address bits + R/W bit) the address bits are located at shift_reg[7:1]. Because of this off-by-one indexing, the DUT never recognizes a matching address and therefore never asserts sda_out_en to drive the ACK low. Evidence:</p>
<ul>
<li>design.sv line 78-83: shifting uses shift_reg <= {shift_reg[6:0], sda}; after 8 shifts address bits occupy shift_reg[7:1].</li>
<li>design.sv line 82: current comparison is if (shift_reg[6:0] == SLAVE_ADDR) — wrong bits compared.</li>
<li>VCD shows top.dut.sda_out_en remains 0 at every expected ACK sample time, matching the failure mode.</li>
</ul>

<h2>Fix</h2>
<p>Modify the address comparison in design.sv to compare shift_reg[7:1] to SLAVE_ADDR.</p>
<p>File: /home/runner/work/FaultTrace/FaultTrace/simulation/design.sv</p>
<p>Change at line 82:</p>
<pre>
-        if (shift_reg[6:0] == SLAVE_ADDR) begin
+        if (shift_reg[7:1] == SLAVE_ADDR) begin
             state <= ACK_ADDR;
         end else begin
             state <= IDLE; // Not our address
         end
</pre>

<h3>Unified patch (context)</h3>
<pre>
--- a/simulation/design.sv
+++ b/simulation/design.sv
@@
-                                if (shift_reg[6:0] == SLAVE_ADDR) begin
+                                if (shift_reg[7:1] == SLAVE_ADDR) begin
                                     state <= ACK_ADDR;
                                 end else begin
                                     state <= IDLE; // Not our address
                                 end
</pre>

<h2>Why this is a DUT bug (not testbench)</h2>
<ul>
<li>The UVM driver correctly releases SDA to float high at ACK sample times (top.intf.sda_drive_out=1) and the pullup produces SDA=1, as shown in VCD.</li>
<li>The DUT internal signal sda_out_en never goes high at those times (VCD top.dut.sda_out_en=0), proving the slave never attempted to pull ACK low.</li>
<li>Root cause is in the RTL comparison of received bits to SLAVE_ADDR (design.sv). Testbench/driver behavior matches I2C master expectations.</li>
</ul>

<h2>Next Steps / Action Items</h2>
<ol>
<li>Apply the change in design.sv at line 82: replace shift_reg[6:0] with shift_reg[7:1].</li>
<li>Re-run the simulation and confirm that top.dut.sda_out_en asserts during ACK windows and UVM_ERRORs disappear.
<li>Add a transient log or UVM_INFO print inside DUT (temporary) to display received shift_reg when address is captured to quickly debug future issues, or add assertions to check ACK timing.</li>
<li>Add a unit test that writes a different address to ensure NACK path still works.</li>
</ol>

<h2>Appendix</h2>
<ul>
<li>sim.log: /home/runner/work/FaultTrace/FaultTrace/simulation/sim.log</li>
<li>design.sv: /home/runner/work/FaultTrace/FaultTrace/simulation/design.sv (lines shown above)</li>
<li>testbench.sv: /home/runner/work/FaultTrace/FaultTrace/simulation/testbench.sv (driver check_ack at ~line 140)
<li>VCD: /home/runner/work/FaultTrace/FaultTrace/simulation/sim.vcd (sampled signals used above)</li>
</ul>


</body>
</html>