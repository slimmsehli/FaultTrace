<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Rtl Bug I2C Ack 20260211</title>
  <style>
body{font-family:system-ui,Segoe UI,Helvetica,Arial;margin:20px;line-height:1.45} pre{background:#f6f8fa;padding:12px;border-radius:6px;overflow:auto} h1{font-size:20px} h2{font-size:16px;margin-top:16px}
</style>
</head>
<body>
<h1>RTL Bug Report - I2C ACK Failure (ANALYSIS_ID: i2c-ack-20260211)</h1>

<h2>1) Summary</h2>
<ul>
<li>Module: i2c_slave_dut (design.sv)</li>
<li>Test: i2c_test (testbench.sv)</li>
<li>Repro command / log: /home/runner/work/FaultTrace/FaultTrace/simulation/sim.log</li>
<li>Artifacts: design.sv, testbench.sv, sim.vcd, sim.log (all under /home/runner/work/FaultTrace/FaultTrace/simulation/)</li>
</ul>

<h2>2) Symptoms & Evidence</h2>
<ul>
<li>UVM errors in sim.log show repeated NACKs during Address and Data phases:
<pre>/home/runner/work/FaultTrace/FaultTrace/simulation/sim.log
UVM_ERROR testbench.sv(146) @ 1795: uvm_test_top.env.agent.driver [DRV] NACK (No ACK) received during Address phase
UVM_ERROR testbench.sv(146) @ 3545: uvm_test_top.env.agent.driver [DRV] NACK (No ACK) received during Data phase
... (repeated for subsequent transactions)
</pre>
</li>
<li>At timestamp 1795 (first NACK): VCD snapshot shows the master released SDA and SCL is high, but DUT never asserted ACK drive.
<pre>
Signals @ 1795 ns:
 top.intf.sda            = 1
 top.intf.sda_drive_out  = 1   (master released SDA)
 top.intf.scl            = 1   (clock)
 top.intf.scl_drive_out  = 1
 top.dut.sda_out_en      = 0   (dut never drove ACK)
 top.dut.sda_d           = 1
 top.dut.scl_d           = 1
</pre>
</li>
<li>Waveform summary (sda, sda_drive_out) shows master toggling lines but DUT.sda_out_en remains 0 across transactions (sim.vcd).</li>
</ul>

<h2>3) Root Cause</h2>
<p>Bug is in the DUT (design.sv). The slave's address-match logic uses a non-blocking update to the shift register (shift_reg <= {shift_reg[6:0], sda}) and immediately compares shift_reg[6:0] in the same clock cycle to decide whether to ACK. Because the new bit is written to shift_reg with a non-blocking assignment, the comparison uses the old contents (off-by-one), so the received 7-bit address is not compared correctly and the DUT never transitions to ACK_ADDR. As a result sda_out_en is never asserted and the master observes NACK.</p>

<p>Specific location (file + lines): /home/runner/work/FaultTrace/FaultTrace/simulation/design.sv. Relevant block around MATCH_ADDR and the comparison at approximately lines 70-92 (shown below):</p>
<pre>
// File: /home/runner/work/FaultTrace/FaultTrace/simulation/design.sv
MATCH_ADDR: begin
    if (scl_rising) begin
        shift_reg <= {shift_reg[6:0], sda};
        if (bit_cnt == 7) begin
            // 7 bits addr + 1 bit R/W. 
            // We check top 7 bits against SLAVE_ADDR
            if (shift_reg[6:0] == SLAVE_ADDR) begin
                state <= ACK_ADDR;
            end else begin
                state <= IDLE; // Not our address
            end
            bit_cnt <= 0;
        end else begin
            bit_cnt <= bit_cnt + 1;
        end
    end
end
</pre>

<p>Two specific issues combined: (A) incorrect bits used for address compare (should examine the full byte and extract bits [7:1] for the 7-bit address), and (B) using non-blocking assignment to update shift_reg then reading it in the same cycle prevents the new bit from being visible for the comparison.</p>

<h2>4) Fix</h2>
<p>Change the MATCH_ADDR handling to compute the next_shift (blocking or temporary variable) that includes the current sampled SDA, then compare next_shift[7:1] to SLAVE_ADDR. Update shift_reg non-blocking from next_shift for correct sequencing.</p>

<p>Suggested code change (apply in /home/runner/work/FaultTrace/FaultTrace/simulation/design.sv, replace the MATCH_ADDR section). The patch below shows the minimal, deterministic fix (use of a temporary next_shift):</p>
<pre>
--- design.sv (original around MATCH_ADDR)
    if (scl_rising) begin
        shift_reg <= {shift_reg[6:0], sda};
        if (bit_cnt == 7) begin
            if (shift_reg[6:0] == SLAVE_ADDR) begin
                state <= ACK_ADDR;
            end else begin
                state <= IDLE;
            end
            bit_cnt <= 0;
        end else begin
            bit_cnt <= bit_cnt + 1;
        end
    end

--- design.sv (fixed)
    if (scl_rising) begin
        logic [7:0] next_shift; // add a temporary
        next_shift = {shift_reg[6:0], sda}; // blocking = immediate view including current sda

        if (bit_cnt == 7) begin
            // Compare bits [7:1] (MSB first transmission) to 7-bit SLAVE_ADDR
            if (next_shift[7:1] == SLAVE_ADDR) begin
                state <= ACK_ADDR;
            end else begin
                state <= IDLE; // Not our address
            end
            shift_reg <= next_shift; // update registered shift_reg
            bit_cnt <= 0;
        end else begin
            shift_reg <= next_shift;
            bit_cnt <= bit_cnt + 1;
        end
    end
</pre>

<p>Patch location: file /home/runner/work/FaultTrace/FaultTrace/simulation/design.sv, inside the always block around line ~70-92 (the MATCH_ADDR case). Add the temporary local declaration (e.g., "logic [7:0] next_shift;") in scope as shown.</p>

<h2>5) Why this is a DUT bug (not testbench)</h2>
<ul>
<li>Testbench clearly drives the master lines and releases SDA for ACK (see testbench.sv lines near 120-150: the driver sets vif.sda_drive_out <= 1'b1 and then samples vif.sda). VCD confirms master released SDA (top.intf.sda_drive_out = 1) and SCL is high when sampling.</li>
<li>The DUT signal controlling the ACK (top.dut.sda_out_en) remains 0 at the sample times, showing DUT never attempted to ACK. This points to the DUT address-detection logic failing rather than a testbench timing error.</li>
</ul>

<h2>6) Next Steps / Action Items</h2>
<ul>
<li>Apply the code change shown above to design.sv at the specified lines. Re-run the simulation and verify that top.dut.sda_out_en toggles low during the ACK cycles and UVM_ERRORs disappear.</li>
<li>Optional: add a small self-check in the DUT to log when an address match occurs to simplify debugging (temporary uvm-style $display). Also consider synchronizing SCL sampling more robustly (synchronizers) if clock domains differ.</li>
</ul>

<h2>7) Appendix - Evidence</h2>
<ul>
<li>sim.log excerpt: /home/runner/work/FaultTrace/FaultTrace/simulation/sim.log (first errors shown at lines near top): UVM_ERROR testbench.sv(146) @ 1795</li>
<li>VCD snapshot used: /home/runner/work/FaultTrace/FaultTrace/simulation/sim.vcd (signals sampled at 1795 ns)</li>
</ul>

<hr>
<p>Report generated by automated RTL analysis on 2026-02-11.</p>


</body>
</html>