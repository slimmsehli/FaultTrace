<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>I2C ACK Failure Analysis</title>
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; line-height:1.55; margin:32px 24px; background:#fafbfc; color:#1f2937 }
    h1,h2,h3 { color:#1f2937; margin-top:0 }
    .card { background:#ffffff; padding:20px 24px; border-radius:12px; margin-bottom:24px; box-shadow:0 1px 3px rgba(0,0,0,0.10),0 1px 2px rgba(0,0,0,0.06); border:1px solid #e5e7eb }
    .subcard { background:#f9fafb; padding:16px; border-radius:10px; margin-top:12px; border:1px solid #e5e7eb }
    .muted { color:#4b5563 }
    pre { background:#0f172a; color:#e6eef8; padding:12px; border-radius:8px; overflow:auto }
    code { font-family: Menlo, Monaco, monospace }
    .ok { color:#059669; font-weight:600 }
    .bad { color:#dc2626; font-weight:700 }
  </style>
</head>
<body>
  <h1>I2C ACK Failure — Root Cause Analysis</h1>
  <div class="card">
    <h2>Summary</h2>
    <p class="muted">Investigated UVM errors in /home/runner/work/FaultTrace/FaultTrace/simulation/sim.log showing repeated NACKs reported by the driver:</p>
    <ul>
      <li>First UVM_ERROR: testbench.sv(146) @ 1795: "NACK (No ACK) received during Address phase"</li>
      <li>Environment: testbench and DUT under /home/runner/work/FaultTrace/FaultTrace/simulation/</li>
    </ul>
  </div>

  <div class="card">
    <h2>Evidence (logs & waveforms)</h2>
    <div class="subcard">
      <p><strong>sim.log</strong> (excerpt):</p>
      <pre><code>UVM_INFO testbench.sv(84) @ 0: uvm_test_top.env.agent.driver [DRV] Starting Write: Addr=50 Data=95
UVM_ERROR testbench.sv(146) @ 1795: uvm_test_top.env.agent.driver [DRV] NACK (No ACK) received during Address phase</code></pre>
      <p>VCD sampling at the first error time (1795 ns):</p>
      <ul>
        <li>top.intf.sda = 1</li>
        <li>top.intf.scl = 1</li>
        <li>top.intf.sda_drive_out = 1 (master released SDA)</li>
        <li>top.intf.scl_drive_out = 1</li>
        <li>top.clk = 1</li>
      </ul>
      <p class="muted">Master correctly released SDA and sampled while SCL=1, but SDA remained high — slave did not assert ACK.</p>
    </div>
  </div>

  <div class="card">
    <h2>Root cause</h2>
    <p>Design bug in i2c_slave_dut address-match logic (file: <strong>/home/runner/work/FaultTrace/FaultTrace/simulation/design.sv</strong>).</p>
    <p class="muted">Details:</p>
    <ul>
      <li>Inside MATCH_ADDR the code uses a non-blocking update: <code>shift_reg &lt;= {shift_reg[6:0], sda};</code> and immediately (in the same clock cycle) compares <code>shift_reg[6:0] == SLAVE_ADDR</code> when <code>bit_cnt == 7</code>.</li>
      <li>Because non-blocking assignments take effect after the current time-step, the comparison reads the old shift_reg (not including the most-recent sampled bit). The code therefore compares the wrong 7-bit field and never matches the master's 7-bit address — the DUT never drives ACK.</li>
      <li>This is consistent with waveforms: at ACK sampling time SDA remains high (no ACK driven) though the master released the line.</li>
    </ul>
  </div>

  <div class="card">
    <h2>Location in source</h2>
    <p>File: /home/runner/work/FaultTrace/FaultTrace/simulation/design.sv</p>
    <p>Problem block starts at approximately line 68 (MATCH_ADDR case). Current code around the check:</p>
    <div class="subcard">
      <pre><code>// design.sv around line ~68
if (scl_rising) begin
    shift_reg <= {shift_reg[6:0], sda};
    if (bit_cnt == 7) begin
        // 7 bits addr + 1 bit R/W.
        // We check top 7 bits against SLAVE_ADDR
        if (shift_reg[6:0] == SLAVE_ADDR) begin
            state <= ACK_ADDR;
        end else begin
            state <= IDLE; // Not our address
        end
        bit_cnt <= 0;
    end else begin
        bit_cnt <= bit_cnt + 1;
    end
end</code></pre>
    </div>
  </div>

  <div class="card">
    <h2>Fix</h2>
    <p class="muted">Make the comparison use the just-sampled byte (including the current sda) instead of reading the pre-update shift_reg. Two practical fixes are shown; I recommend option A.</p>

    <h3>Option A — Compute <code>next_shift</code> and compare its bits (recommended)</h3>
    <p>Change code in <strong>/home/runner/work/FaultTrace/FaultTrace/simulation/design.sv</strong> in the MATCH_ADDR case (around line 68). Replace the block shown above with:</p>
    <div class="subcard">
      <pre><code>// Replace MATCH_ADDR sampling block (design.sv lines ~68-86)
if (scl_rising) begin
    // Compute next shift register value (blocking local variable)
    logic [7:0] next_shift;
    next_shift = {shift_reg[6:0], sda};

    if (bit_cnt == 7) begin
        // Address is in bits [7:1] of the sampled byte; bit 0 is R/W
        if (next_shift[7:1] == SLAVE_ADDR) begin
            state <= ACK_ADDR;
        end else begin
            state <= IDLE; // Not our address
        end
        shift_reg <= next_shift; // store for later use
        bit_cnt <= 0;
    end else begin
        shift_reg <= next_shift;
        bit_cnt <= bit_cnt + 1;
    end
end</code></pre>
    </div>
    <p class="muted">This fixes the non-blocking/ordering issue by building the sampled byte and testing the correct 7 bits immediately.</p>

    <h3>Option B — Delay the comparison to next clock edge</h3>
    <p>Alternatively, update shift_reg as done today, but only perform the address comparison on the next clock cycle (i.e., transition to a small sub-state after the 8th sample). This is more invasive and not required here.</p>
  </div>

  <div class="card">
    <h2>Why this is a DUT bug (not testbench)</h2>
    <ul>
      <li>The testbench driver releases SDA and samples at the expected time (VCD shows top.intf.sda_drive_out = 1 and top.intf.scl = 1 at sampling).</li>
      <li>The DUT failed to assert ACK even though the master performed the correct sequence. The incorrect comparison in design.sv prevents address recognition.</li>
    </ul>
  </div>

  <div class="card">
    <h2>Reproduction steps</h2>
    <ol>
      <li>Run existing simulation (files under /home/runner/work/FaultTrace/FaultTrace/simulation/). The first UVM_ERROR appears at ~1795 ns.</li>
      <li>Apply the patch above to design.sv and re-run. The driver should log an ACK during the address phase instead of the UVM_ERROR.</li>
    </ol>
  </div>

  <div class="card">
    <h2>Files touched</h2>
    <ul>
      <li>/home/runner/work/FaultTrace/FaultTrace/simulation/design.sv — modify MATCH_ADDR sampling and comparison (around lines 68-86).</li>
    </ul>
  </div>

  <div class="card">
    <h2>Appendix — Quick checklist</h2>
    <ul>
      <li>Apply Option A change at design.sv lines ~68-86.</li>
      <li>Re-run simulation and verify sim.log no longer contains UVM_ERROR testbench.sv(146) at ~1795 ns.</li>
      <li>Verify sim.vcd shows top.intf.sda driven low by the DUT during ACK cycle.</li>
    </ul>
  </div>

</body>
</html>