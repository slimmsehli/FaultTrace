<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Rtl Bug Analysis 0001 I2C Slave 20260213</title>
  <style>
body { font-family: system-ui, sans-serif; line-height: 1.5; margin: 2rem; color: #333; } pre { background: #f4f4f4; padding: 1rem; border-radius: 4px; border: 1px solid #ddd; } .timing-diagram { font-family: "Courier New", Courier, monospace; line-height: 1.2; background: #1e1e1e; color: #dcdcdc; padding: 1rem; } .confidence-high { color: #28a745; font-weight: bold; }
</style>
</head>
<body>
<h1>RTL Bug Report – ANALYSIS-0001: i2c_slave_dut NACKs (Address/Data)</h1>
<p class="confidence-high">Confidence: 90% - Root cause verified via VCD timing (slave not driving ACK) and RTL logic inspection showing an off-by-one due to non-blocking update of shift_reg.</p>

<h2>Summary</h2>
<ul>
<li>Module: i2c_slave_dut (simulation/design.sv)</li>
<li>Commit / Version: workspace copy under /home/runner/work/FaultTrace/FaultTrace/simulation (no VCS commit metadata)</li>
<li>Repro command: run_test("i2c_test") (see simulation run in sim.log)</li>
<li>Environment: VCS simulation; timescale 1ns; VCD at simulation/sim.vcd</li>
</ul>

<h2>Symptoms & Evidence</h2>
<p>UVM errors from driver reporting NACKs during Address and Data phases in simulation log:</p>
<pre>
UVM_ERROR testbench.sv(146) @ 1795: uvm_test_top.env.agent.driver [DRV] NACK (No ACK) received during Address phase
UVM_ERROR testbench.sv(146) @ 3545: uvm_test_top.env.agent.driver [DRV] NACK (No ACK) received during Data phase
(Repeated for three transactions)
</pre>

<p>At the first failure time (1795 ns) the VCD shows:</p>
<pre>
Signals @ 1795 ns
- top.intf.scl = 1
- top.intf.sda = 1   (line released / high)
- top.intf.sda_drive_out = 1 (master released SDA to read ACK)
- top.dut.sda_out_en = 0      (slave NOT driving ACK low)
- top.dut.sda = 1
</pre>

<p>This means the master released SDA to sample the ACK bit but the DUT did not drive SDA low → master sees NACK.</p>

<h2>Relevant source locations</h2>
<ul>
<li>Testbench/driver: /home/runner/work/FaultTrace/FaultTrace/simulation/testbench.sv
  - Driver check_atk UVM_ERROR emitted at testbench.sv line 146 (see logging call). (lines shown in file)</li>
<li>DUT: /home/runner/work/FaultTrace/FaultTrace/simulation/design.sv
  - Address sampling and ACK generation logic around lines 76-90 (file lines from workspace):
</li>
</ul>

<h2>Root Cause (concise)</h2>
<p>The slave's address-match logic compares the wrong shift register contents because shift_reg is updated with a non-blocking assignment (<=) and then immediately compared in the same sequential block. The comparison therefore uses the old value (one bit behind) and the slave never recognizes the intended 7-bit address + R/W. As a result the DUT never transitions into the ACK state and does not pull SDA low for the ACK bit. This causes the master to see a NACK.</p>

<h2>Technical details (why this matters)</h2>
<ul>
<li>In the sequential always @(posedge clk ...) block, non-blocking assignments (<=) schedule updates for the end of the time-step. Any expression that compares shift_reg immediately after shift_reg <= {shift_reg[6:0], sda}; will read the previous value, not the new shifted-in bit.</li>
<li>The code does: shift_reg <= {shift_reg[6:0], sda}; if (bit_cnt == 7) if (shift_reg[6:0] == SLAVE_ADDR) ... which is off-by-one.</li>
</ul>

<h2>Minimal Fix</h2>
<p>Edit: /home/runner/work/FaultTrace/FaultTrace/simulation/design.sv</p>
<p>Replace the MATCH_ADDR block (around lines 76-90) with code that computes the next_shift into a temporary variable and uses that for comparison so the freshly sampled bit is included in the address comparison.</p>

<pre>
--- file: simulation/design.sv (around lines 76-90)
-                    MATCH_ADDR: begin
-                        if (scl_rising) begin
-                            shift_reg <= {shift_reg[6:0], sda};
-                            if (bit_cnt == 7) begin
-                                // 7 bits addr + 1 bit R/W. 
-                                // We check top 7 bits against SLAVE_ADDR
-                                if (shift_reg[6:0] == SLAVE_ADDR) begin
-                                    state <= ACK_ADDR;
-                                end else begin
-                                    state <= IDLE; // Not our address
-                                end
-                                bit_cnt <= 0;
-                            end else begin
-                                bit_cnt <= bit_cnt + 1;
-                            end
-                        end
-                    end
+                    MATCH_ADDR: begin
+                        if (scl_rising) begin
+                            // Compute next shift value including current sampled bit
+                            logic [7:0] next_shift;
+                            next_shift = {shift_reg[6:0], sda};
+                            shift_reg <= next_shift;
+                            if (bit_cnt == 7) begin
+                                // After 8 bits have been sampled, next_shift[7:1] contains the 7-bit address
+                                if (next_shift[7:1] == SLAVE_ADDR) begin
+                                    state <= ACK_ADDR;
+                                end else begin
+                                    state <= IDLE; // Not our address
+                                end
+                                bit_cnt <= 0;
+                            end else begin
+                                bit_cnt <= bit_cnt + 1;
+                            end
+                        end
+                    end
</pre>

<p>File/line guidance:
- Open /home/runner/work/FaultTrace/FaultTrace/simulation/design.sv
- Modify block starting at line 76 (as in workspace file with line numbers). The diff above is minimal and keeps original clocking structure.
</p>

<h2>Why this is a DUT bug (not testbench)</h2>
<p>The testbench drives the expected I2C waveform and releases SDA for ACK sampling (VCD shows master releasing SDA and SCL high at the sample time). The DUT fails to assert ACK because internal RTL logic compares stale shift_reg contents — this is a design (DUT) logic bug.</p>

<h2>Next steps & Verification</h2>
<ol>
<li>Apply the patch above to simulation/design.sv at the indicated lines.
<li>Rerun the simulation (same run_test). Check sim.log: UVM_ERROR count should drop (ACK info logs should appear).</li>
<li>Open sim.vcd and verify that at the ACK sample times (master releases SDA) top.dut.sda_out_en becomes 1 and top.dut.sda goes to 0 during the ACK bit window.
</ol>

<h2>Visual timing diagram (excerpt around first Address ACK sample)</h2>
<pre class="timing-diagram">
SCL  : ____/‾‾‾‾\____      (rising during sample)
SDA  : ‾‾‾‾‾‾‾‾\________     (master data then releases for ACK)
Master_sda_drive_out: 1111111   (1=released)
Slave_sda_out_en     : 0000000   (expected: should assert 0->1 during ACK) 
State               : MATCH_ADDR | (expected -> ACK_ADDR)
Time(ns)            : 1695     1745    1795
</pre>

<h2>Appendix / Artifacts</h2>
<ul>
<li>Simulation log: simulation/sim.log</li>
<li>VCD: simulation/sim.vcd (signals inspected: top.intf.sda, top.intf.sda_drive_out, top.dut.sda_out_en, top.dut.sda, top.intf.scl, top.intf.scl_drive_out)</li>
<li>Files inspected:
  <ul>
    <li>/home/runner/work/FaultTrace/FaultTrace/simulation/testbench.sv</li>
    <li>/home/runner/work/FaultTrace/FaultTrace/simulation/design.sv</li>
  </ul>
</li>
</ul>

<p>Report generated by RTL Verification analysis toolchain.</p>


</body>
</html>